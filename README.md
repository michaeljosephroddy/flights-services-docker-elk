**Flightservice Deployment Documentation**

### Microservices Architecture Overview
Microservices architecture is a software development approach that breaks an application into small, independent services. Each service handles a specific business function and can be developed, deployed, and scaled independently. This approach offers several benefits:

- **Improved Scalability:** Each service can be scaled independently based on demand.
- **Enhanced Maintainability:** Small, modular services are easier to update and debug.
- **Increased Resilience:** Failures in one service are less likely to affect the entire system.

### Containerization and Orchestration
Containerization, enabled by tools like Docker, provides a lightweight and portable way to package applications and their dependencies. Containers ensure consistent behavior across environments by isolating applications from the underlying host system.

To manage and scale containerized microservices, orchestration tools automate tasks such as:

- **Deployment**
- **Scaling**
- **Load Balancing**
- **Service Discovery**

These tools simplify the management of complex microservices architectures.

---

### Docker Compose Deployment
Docker Compose is a tool for defining and running multi-container Docker applications using a YAML configuration file. This file specifies the services, dependencies, and configurations required for the application.

#### Deployment Steps
1. **Define the Docker Compose File:**
   - The `docker-compose.yml` includes the configuration for a Java microservice, MySQL database, and the ELK stack.

2. **Dependencies:**
   - The following files are required:
     - `init.sql`  
     - `logstash.conf`
     - `flightservices.jar`

3. **Run the Containers:**
   ```bash
   sudo docker-compose up --build
   ```
   - This command launches the containers locally.

4. **Test the Application:**
   - Call the `/flights` endpoint:
     ```bash
     curl http://localhost:8080/flights/
     ```
   - The Java microservice logs entries to `logs/application.log` using SLF4J.

5. **Log Management:**
   - Logstash collects log entries and sends them to Elasticsearch for indexing.
   - Use Kibana to monitor logs at:
     ```
     http://localhost:5601
     ```

---

### Docker Swarm Deployment
Docker Swarm is a native clustering solution for Docker, allowing you to manage and scale applications across a cluster of machines. It turns a pool of Docker hosts into a single, virtual Docker host.

#### Deployment Steps
1. **Setup Infrastructure:**
   - Use Terraform to provision three EC2 instances, see `main.tf`:
     ```bash
     terraform init
     terraform plan
     terraform apply
     ```

2. **Initialize Docker Swarm:**
   - SSH into the manager node and run:
     ```bash
     docker swarm init
     ```
   - Copy the join key generated by the command.

3. **Join Worker Nodes:**
   - SSH into each worker node and use the join key:
     ```bash
     docker swarm join --token <WORKER_TOKEN> <MANAGER_IP>:2377
     ```

4. **Deploy the Application:**
   - On the manager node, deploy the stack:
     ```bash
     docker stack deploy -c docker-compose.yml <stack_name>
     ```

5. **Scale Services:**
   - Adjust replicas as needed:
     ```bash
     docker service scale <stack_name>_<service_name>=<number_of_replicas>
     ```

6. **Update Services:**
   - Update a service to a new version:
     ```bash
     docker service update --image <image_name> <stack_name>
     ```
   - Rollback to a previous version if needed:
     ```bash
     docker service rollback <stack_name>
     ```

#### Benefits of Docker Swarm
- **Simplified Scaling:** Easily scale services across a cluster of machines.
- **High Availability:** Distribute services across multiple nodes to ensure resilience.
- **Native Integration:** Seamlessly integrates with Docker tools and workflows.

